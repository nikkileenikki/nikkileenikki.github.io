<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Live OTT Overlay (Web)</title>

  <link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet" />

  <style>
    body { margin: 0; background: #000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .player-wrap { position: relative; width: 100vw; height: 100vh; }
    #livePlayer { width: 100%; height: 100%; }

    #adOverlay {
      position: absolute; inset: 0;
      display: none;
      align-items: center; justify-content: center;
      background: rgba(0, 0, 0, 0.35);
      z-index: 10;
      pointer-events: none;
    }

    #adBox {
      position: relative;
      width: 100%;
      height: 100%;
      aspect-ratio: 16 / 9;
      background: #000;
      border-radius: 16px;
      overflow: hidden;
      pointer-events: auto;
      box-shadow: 0 20px 50px rgba(0,0,0,.6);
    }

    #adVideo { width: 100%; height: 100%; }

    #adUI {
      position: absolute; inset: 0;
      display: flex; flex-direction: column;
      justify-content: space-between;
      padding: 12px; color: #fff;
      pointer-events: none;
    }

    #adTop { display: flex; justify-content: space-between; align-items: center; }

    #badge {
      background: rgba(0,0,0,.6);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
    }

    #skipBtn {
      pointer-events: auto;
      display: none!important;
      background: rgba(255,255,255,.15);
      border: 1px solid rgba(255,255,255,.25);
      color: #fff;
      padding: 6px 12px;
      border-radius: 999px;
      cursor: pointer;
    }

    #tapHint {
      position: absolute;
      left: 12px; right: 12px; bottom: 12px;
      background: rgba(0,0,0,.6);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 12px;
      display: none;
      pointer-events: auto;
      cursor: pointer;
      user-select: none;
      text-align: center;
      z-index: 30;
    }

    /* Debug panel */
    #debugPanel {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 50;
      background: rgba(0,0,0,.65);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 12px;
      padding: 10px 12px;
      color: #fff;
      font-size: 12px;
      line-height: 1.35;
      max-width: min(520px, 92vw);
      user-select: text;
    }
    #debugPanel .row { display: flex; gap: 8px; }
    #debugPanel .k { opacity: .75; min-width: 150px; }
    #debugPanel .v { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; word-break: break-all; }
  </style>
</head>

<body>
  <div class="player-wrap">
    <video
      id="livePlayer"
      class="video-js vjs-default-skin"
      autoplay
      muted
      controls
      playsinline
    ></video>

    <!-- Debug -->
    <div id="debugPanel">
      <div class="row"><div class="k">Program time:</div><div class="v" id="dbgProgram">-</div></div>
      <div class="row"><div class="k">Program unix ms:</div><div class="v" id="dbgProgramMs">-</div></div>
      <div class="row"><div class="k">Player currentTime:</div><div class="v" id="dbgCT">-</div></div>
      <div class="row"><div class="k">Paused:</div><div class="v" id="dbgPaused">-</div></div>
      <div class="row"><div class="k">Schedule items:</div><div class="v" id="dbgItems">-</div></div>
      <div class="row"><div class="k">Next break (startUnix):</div><div class="v" id="dbgNext">-</div></div>
      <div class="row"><div class="k">Next break in:</div><div class="v" id="dbgNextIn">-</div></div>
      <div class="row"><div class="k">ProgramDateTime seen:</div><div class="v" id="dbgPdtSeen">-</div></div>
    </div>

    <div id="adOverlay">
      <div id="adBox">
        <video id="adVideo" playsinline></video>

        <div id="adUI">
          <div id="adTop">
            <div id="badge">Ad • <span id="countdown">15</span>s</div>
            <button id="skipBtn">Skip</button>
          </div>
        </div>

        <div id="tapHint">Tap to enable sound</div>
      </div>
    </div>
  </div>

  <script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>

  <script>
    /*************************************************
     * CONFIG
     *************************************************/
    const HLS_URL =
      "https://demo.unified-streaming.com/k8s/live/stable/live.isml/stream_1.m3u8";

    const SCHEDULE_URL =
      "https://nikkileenikki.github.io/test/schedule.json";

    const WORKER_BASE =
      "https://time-api2.nikki-lee-nikki.workers.dev";

    const TIME_URL = WORKER_BASE + "/time";
    const VAST_PROXY = WORKER_BASE + "/vast?url=";

    /*************************************************
     * AUDIO STATE
     *************************************************/
    let soundEnabled = false;

    function enableSound() {
      soundEnabled = true;
      if (!playing) player.muted(false);
    }
    window.addEventListener("pointerdown", enableSound, { once: true });
    window.addEventListener("keydown", enableSound, { once: true });

    /*************************************************
     * PLAYER INIT
     *************************************************/
    const player = videojs("livePlayer", {
      liveui: true,
      html5: { vhs: { overrideNative: true } },
      sources: [{ src: HLS_URL, type: "application/x-mpegURL" }]
    });

    let isPaused = false;
    player.on("pause", () => isPaused = true);
    player.on("play", () => isPaused = false);

    /*************************************************
     * PROGRAM TIME (EXT-X-PROGRAM-DATE-TIME)
     *************************************************/
    function getProgramTimeUnixMs() {
      try {
        const tech = player.tech(true);
        const vhs = tech && tech.vhs;
        const pl = vhs && vhs.playlists && vhs.playlists.media && vhs.playlists.media();
        if (!pl || !pl.segments || !pl.segments.length) return null;

        const ct = player.currentTime();
        let acc = 0;

        for (const seg of pl.segments) {
          const dur = seg.duration || pl.targetDuration || 6;
          if (ct >= acc && ct < acc + dur) {
            if (!seg.programDateTime) return null;
            const segStartMs = (seg.programDateTime instanceof Date)
              ? seg.programDateTime.getTime()
              : Date.parse(seg.programDateTime);
            const offsetMs = (ct - acc) * 1000;
            return segStartMs + offsetMs;
          }
          acc += dur;
        }

        const last = pl.segments[pl.segments.length - 1];
        if (last && last.programDateTime) {
          const lastMs = (last.programDateTime instanceof Date)
            ? last.programDateTime.getTime()
            : Date.parse(last.programDateTime);
          return lastMs;
        }

        return null;
      } catch {
        return null;
      }
    }

    function getAnyProgramDateTimeSeen() {
      try {
        const tech = player.tech(true);
        const vhs = tech && tech.vhs;
        const pl = vhs && vhs.playlists && vhs.playlists.media && vhs.playlists.media();
        const segs = pl && pl.segments;
        if (!segs || !segs.length) return null;
        const any = segs.find(s => s.programDateTime);
        if (!any) return null;
        const ms = (any.programDateTime instanceof Date) ? any.programDateTime.getTime() : Date.parse(any.programDateTime);
        return { raw: any.programDateTime, iso: new Date(ms).toISOString() };
      } catch {
        return null;
      }
    }

    /*************************************************
     * TIME SYNC (fallback only)
     *************************************************/
    async function getServerOffsetMs() {
      try {
        const t0 = performance.now();
        const r = await fetch(TIME_URL, { cache: "no-store", mode: "cors" });
        const j = await r.json();
        const t1 = performance.now();
        return (j.unixMs + (t1 - t0) / 2) - Date.now();
      } catch (e) {
        console.warn("Time sync failed, using device time:", e);
        return 0;
      }
    }

    let serverOffsetMs = 0;
    let schedule = [];
    let playing = false;
    const playedIds = new Set();

    /*************************************************
     * OVERLAY CONTROL
     *************************************************/
    const overlay = document.getElementById("adOverlay");
    const adVideo = document.getElementById("adVideo");
    const countdownEl = document.getElementById("countdown");
    const skipBtn = document.getElementById("skipBtn");
    const tapHint = document.getElementById("tapHint");

    function showOverlay() { overlay.style.display = "flex"; }
    function hideOverlay() { overlay.style.display = "none"; tapHint.style.display = "none"; }

    function fireBeacon(url) {
      if (!url) return;
      const img = new Image();
      img.src = url + (url.includes("?") ? "&" : "?") + "cb=" + Math.random();
    }

    async function fetchVastXml(vastUrl) {
      const proxied = VAST_PROXY + encodeURIComponent(vastUrl);
      const r = await fetch(proxied, { cache: "no-store", mode: "cors" });
      if (!r.ok) throw new Error("VAST fetch failed: " + r.status);
      return await r.text();
    }

    function pickFirstMediaFile(doc) {
      const mediaFiles = Array.from(doc.getElementsByTagName("MediaFile"));
      const mp4 = mediaFiles.find(n => ((n.getAttribute("type") || "").toLowerCase().includes("mp4"))) || mediaFiles[0];
      return mp4 ? (mp4.textContent || "").trim() : null;
    }

    function getImpressions(doc) {
      return Array.from(doc.getElementsByTagName("Impression"))
        .map(n => (n.textContent || "").trim())
        .filter(Boolean);
    }

    function getTracking(doc) {
      const out = {};
      const nodes = Array.from(doc.getElementsByTagName("Tracking"));
      for (const n of nodes) {
        const ev = n.getAttribute("event");
        const u = (n.textContent || "").trim();
        if (!ev || !u) continue;
        (out[ev] ||= []).push(u);
      }
      return out;
    }

    async function resolveVast(vastUrl, maxWrappers = 3) {
      let current = vastUrl;

      for (let i = 0; i <= maxWrappers; i++) {
        const xml = await fetchVastXml(current);
        const doc = new DOMParser().parseFromString(xml, "text/xml");

        const mediaUrl = pickFirstMediaFile(doc);
        const impressions = getImpressions(doc);
        const tracking = getTracking(doc);

        if (mediaUrl) return { mediaUrl, impressions, tracking };

        const next = doc.getElementsByTagName("VASTAdTagURI")[0];
        const nextUrl = next ? (next.textContent || "").trim() : null;
        if (!nextUrl) throw new Error("No MediaFile and no Wrapper VASTAdTagURI");
        current = nextUrl;
      }

      throw new Error("Too many VAST wrappers");
    }

    async function playOverlayAd(item) {
      if (playing || playedIds.has(item.id)) return;
      if (!item.vastUrl) return;

      playing = true;
      playedIds.add(item.id);

      showOverlay();
      player.muted(true);

      const total = Math.max(5, Number(item.durationSec) || 30);
      let remaining = total;
      countdownEl.textContent = remaining;

      let vast;
      try {
        vast = await resolveVast(item.vastUrl);
      } catch (e) {
        console.error("VAST resolve failed:", e);
        hideOverlay();
        playing = false;
        if (soundEnabled) player.muted(false);
        return;
      }

      (vast.impressions || []).forEach(fireBeacon);

      adVideo.playsInline = true;
      adVideo.preload = "auto";
      adVideo.src = vast.mediaUrl;
      adVideo.load();
      adVideo.muted = !soundEnabled;

      const fired = new Set();
      const tick = setInterval(() => {
        remaining -= 1;
        countdownEl.textContent = Math.max(0, remaining);

        const elapsed = total - remaining;
        const t = adVideo.currentTime || elapsed;
        const d = (adVideo.duration && isFinite(adVideo.duration)) ? adVideo.duration : total;
        const pct = d > 0 ? (t / d) : 0;

        if (!fired.has("start")) { fired.add("start"); (vast.tracking.start || []).forEach(fireBeacon); }
        if (pct >= 0.25 && !fired.has("firstQuartile")) { fired.add("firstQuartile"); (vast.tracking.firstQuartile || []).forEach(fireBeacon); }
        if (pct >= 0.5 && !fired.has("midpoint")) { fired.add("midpoint"); (vast.tracking.midpoint || []).forEach(fireBeacon); }
        if (pct >= 0.75 && !fired.has("thirdQuartile")) { fired.add("thirdQuartile"); (vast.tracking.thirdQuartile || []).forEach(fireBeacon); }

        if (remaining <= 0) stop("timer");
      }, 1000);

      function stop(reason) {
        clearInterval(tick);
        (vast.tracking.complete || []).forEach(fireBeacon);

        adVideo.pause();
        adVideo.removeAttribute("src");
        adVideo.load();

        hideOverlay();
        playing = false;
        if (soundEnabled) player.muted(false);
      }

      adVideo.onended = () => stop("ended");
      adVideo.onerror = () => stop("error");

      try {
        await adVideo.play();
        tapHint.style.display = "none";
      } catch (e) {
        tapHint.style.display = "block";
        tapHint.onclick = async () => {
          try {
            soundEnabled = true;
            adVideo.muted = false;
            await adVideo.play();
            tapHint.style.display = "none";
          } catch (e2) {
            console.warn("Still blocked:", e2);
          }
        };
      }
    }

    /*************************************************
     * SCHEDULER (Program-time driven)
     *************************************************/
    async function loadSchedule() {
      const url = SCHEDULE_URL + "?cb=" + Date.now(); // avoid GH cache
      schedule = await fetch(url, { cache: "no-store" }).then(r => r.json());
    }

    function nowMs() {
      const programMs = getProgramTimeUnixMs();
      if (programMs) return programMs;          // ✅ cue by video time
      return Date.now() + serverOffsetMs;       // fallback
    }

    function startLoop() {
      setInterval(() => {
        if (isPaused) return; // don’t fire while paused
        const t = nowMs();
        const windowMs = 8000;

        for (const item of schedule) {
          const startMs = item.startUnix * 1000;
          if (t >= startMs && t < startMs + windowMs) {
            playOverlayAd(item);
          }
        }
      }, 500);
    }

    /*************************************************
     * DEBUG PANEL
     *************************************************/
    const dbgProgram = document.getElementById("dbgProgram");
    const dbgProgramMs = document.getElementById("dbgProgramMs");
    const dbgCT = document.getElementById("dbgCT");
    const dbgPaused = document.getElementById("dbgPaused");
    const dbgItems = document.getElementById("dbgItems");
    const dbgNext = document.getElementById("dbgNext");
    const dbgNextIn = document.getElementById("dbgNextIn");
    const dbgPdtSeen = document.getElementById("dbgPdtSeen");

    function updateDebug() {
      const programMs = getProgramTimeUnixMs();
      dbgProgramMs.textContent = programMs ? String(Math.round(programMs)) : "-";
      dbgProgram.textContent = programMs ? new Date(programMs).toISOString() : "-";
      dbgCT.textContent = (player && typeof player.currentTime === "function")
        ? player.currentTime().toFixed(3) + "s"
        : "-";
      dbgPaused.textContent = String(isPaused);
      dbgItems.textContent = String(schedule.length);

      // Next break based on program time (or fallback time)
      const t = nowMs();
      const future = schedule
        .map(it => ({ it, startMs: it.startUnix * 1000 }))
        .filter(x => x.startMs >= t)
        .sort((a, b) => a.startMs - b.startMs)[0];

      if (future) {
        dbgNext.textContent = String(future.it.startUnix) + " (" + new Date(future.startMs).toISOString() + ")";
        const diffSec = Math.max(0, Math.round((future.startMs - t) / 1000));
        dbgNextIn.textContent = diffSec + "s";
      } else {
        dbgNext.textContent = "-";
        dbgNextIn.textContent = "-";
      }

      const seen = getAnyProgramDateTimeSeen();
      dbgPdtSeen.textContent = seen ? (seen.iso + "  (raw: " + seen.raw + ")") : "no segment programDateTime yet";
    }

    setInterval(updateDebug, 500);

    /*************************************************
     * BOOT
     *************************************************/
    (async function init() {
      serverOffsetMs = await getServerOffsetMs();
      await loadSchedule();
      setInterval(loadSchedule, 60_000);
      startLoop();
    })();
  </script>
</body>
</html>
